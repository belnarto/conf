{"version":3,"file":"kotlin-extensions.js","sources":["../../../../../kotlin-extensions/src/main/kotlin/kotlinext/js/Helpers.kt","../../../../../kotlin-extensions/src/main/kotlin/kotlinext/js/TemplateTag.kt","kotlin/kotlin.kt"],"sourcesContent":["package kotlinext.js\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninline fun <T : Any> jsObject(): T =\n    js(\"({})\")\n\ninline fun <T : Any> jsObject(builder: T.() -> Unit): T =\n    jsObject<T>().apply(builder)\n\ninline fun js(builder: dynamic.() -> Unit): dynamic = jsObject(builder)\n\nfun <T : Any> clone(obj: T) = Object.assign(jsObject(), obj)\n\ninline fun <T : Any> assign(obj: T, builder: T.() -> Unit) = clone(obj).apply(builder)\n\nfun toPlainObjectStripNull(obj: Any) = js {\n    for (key in Object.keys(obj)) {\n        val value = obj.asDynamic()[key]\n        if (value != null) this[key] = value\n    }\n}\n","package kotlinext.js\n\nexternal interface TemplateTag<in T, out R> {\n    fun call(ctx: Any?, strings: Array<String>, vararg values: T): R\n}\n\noperator fun <T, R> TemplateTag<T, R>.invoke(strings: Array<String>, vararg values: T) =\n    this.call(null, strings, *values)\n\noperator fun <T, R> TemplateTag<T, R>.invoke(string: String, vararg values: T) = this(arrayOf(string), *values)\noperator fun <T, R> TemplateTag<T, R>.invoke(vararg values: T) = this(emptyArray(), *values)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:Suppress(\"UNUSED_PARAMETER\", \"NOTHING_TO_INLINE\")\n\npackage kotlin\n\n/**\n * Returns an empty array of the specified type [T].\n */\npublic inline fun <T> emptyArray(): Array<T> = js(\"[]\")\n\n@library\npublic fun <T> arrayOf(vararg elements: T): Array<T> = definedExternally\n\n@library\npublic fun doubleArrayOf(vararg elements: Double): DoubleArray = definedExternally\n\n@library\npublic fun floatArrayOf(vararg elements: Float): FloatArray = definedExternally\n\n@library\npublic fun longArrayOf(vararg elements: Long): LongArray = definedExternally\n\n@library\npublic fun intArrayOf(vararg elements: Int): IntArray = definedExternally\n\n@library\npublic fun charArrayOf(vararg elements: Char): CharArray = definedExternally\n\n@library\npublic fun shortArrayOf(vararg elements: Short): ShortArray = definedExternally\n\n@library\npublic fun byteArrayOf(vararg elements: Byte): ByteArray = definedExternally\n\n@library\npublic fun booleanArrayOf(vararg elements: Boolean): BooleanArray = definedExternally\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n */\npublic actual fun <T> lazy(initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n *\n * The [mode] parameter is ignored. */\npublic actual fun <T> lazy(mode: LazyThreadSafetyMode, initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n *\n * The [lock] parameter is ignored.\n */\npublic actual fun <T> lazy(lock: Any?, initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n\ninternal fun fillFrom(src: dynamic, dst: dynamic): dynamic {\n    val srcLen: Int = src.length\n    val dstLen: Int = dst.length\n    var index: Int = 0\n    while (index < srcLen && index < dstLen) dst[index] = src[index++]\n    return dst\n}\n\n\ninternal fun arrayCopyResize(source: dynamic, newSize: Int, defaultValue: Any?): dynamic {\n    val result = source.slice(0, newSize)\n    copyArrayType(source, result)\n    var index: Int = source.length\n    if (newSize > index) {\n        result.length = newSize\n        while (index < newSize) result[index++] = defaultValue\n    }\n    return result\n}\n\ninternal fun <T> arrayPlusCollection(array: dynamic, collection: Collection<T>): dynamic {\n    val result = array.slice()\n    result.length += collection.size\n    copyArrayType(array, result)\n    var index: Int = array.length\n    for (element in collection) result[index++] = element\n    return result\n}\n\ninternal fun <T> fillFromCollection(dst: dynamic, startIndex: Int, collection: Collection<T>): dynamic {\n    var index = startIndex\n    for (element in collection) dst[index++] = element\n    return dst\n}\n\ninternal inline fun copyArrayType(from: dynamic, to: dynamic) {\n    if (from.`$type$` !== undefined) {\n        to.`$type$` = from.`$type$`\n    }\n}\n\ninternal inline fun jsIsType(obj: dynamic, jsClass: dynamic) = js(\"Kotlin\").isType(obj, jsClass)"],"names":[],"mappings":";;;;EAWA,oB;IAA8B,OAAA,MAAO,QAPjC,EAOiC,EAAmB,GAAnB,C;G;ECLrC,8C;IACI,Q;IAAA,OAAK,CAAL,gBAAK,oBAAK,IAAL,EAAW,OAAX,SAAqB,MAArB,E;G;EAGT,qC;IAAiE,2BCElB,EDFkB,EAAoB,MAApB,S;G;;;;;;;;"}