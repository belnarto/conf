{"version":3,"file":"kotlin-react.js","sources":["collections/Collections.kt","kotlin/collections.kt","util/Preconditions.kt","../../../../../kotlin-react/src/main/kotlin/react/RBuilder.kt","util/Standard.kt","../../../../../kotlin-extensions/src/main/kotlin/kotlinext/js/Helpers.kt","../../../../../kotlin-react/src/main/kotlin/react/React.kt","../../../../../kotlin-react/src/main/kotlin/react/ReactComponent.kt"],"sourcesContent":["/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n@file:UseExperimental(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * @sample samples.collections.Builders.Lists.buildListSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(@BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return ArrayList<E>().apply(builderAction)\n}\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Lists.buildListSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(capacity: Int, @BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    checkBuilderCapacity(capacity)\n    return ArrayList<E>(capacity).apply(builderAction)\n}\n\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which the given [comparison] function returns zero using the binary search algorithm.\n *\n * The list is expected to be sorted so that the signs of the [comparison] function's return values ascend on the list elements,\n * i.e. negative values come before zero and zeroes come before positive values.\n * Otherwise, the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that returns zero when called on the list element being searched.\n * On the elements coming before the target element, the function must return negative values;\n * on the elements coming after the target element, the function must return positive values.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\nimport kotlin.comparisons.naturalOrder\nimport kotlin.random.Random\n\n/** Returns the array if it's not `null`, or an empty array otherwise. */\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Array<out T>?.orEmpty(): Array<out T> = this ?: emptyArray<T>()\n\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Collection<T>.toTypedArray(): Array<T> = copyToArray(this)\n\n@JsName(\"copyToArray\")\n@PublishedApi\ninternal fun <T> copyToArray(collection: Collection<T>): Array<T> {\n    return if (collection.asDynamic().toArray !== undefined)\n        collection.asDynamic().toArray().unsafeCast<Array<T>>()\n    else\n        copyToArrayImpl(collection).unsafeCast<Array<T>>()\n}\n\n@JsName(\"copyToArrayImpl\")\ninternal actual fun copyToArrayImpl(collection: Collection<*>): Array<Any?> {\n    val array = emptyArray<Any?>()\n    val iterator = collection.iterator()\n    while (iterator.hasNext())\n        array.asDynamic().push(iterator.next())\n    return array\n}\n\n@JsName(\"copyToExistingArrayImpl\")\ninternal actual fun <T> copyToArrayImpl(collection: Collection<*>, array: Array<T>): Array<T> {\n    if (array.size < collection.size)\n        return copyToArrayImpl(collection).unsafeCast<Array<T>>()\n\n    val iterator = collection.iterator()\n    var index = 0\n    while (iterator.hasNext()) {\n        array[index++] = iterator.next().unsafeCast<T>()\n    }\n    if (index < array.size) {\n        array[index] = null.unsafeCast<T>()\n    }\n    return array\n}\n\n/**\n * Returns an immutable list containing only the specified object [element].\n */\npublic fun <T> listOf(element: T): List<T> = arrayListOf(element)\n\n/**\n * Returns an immutable set containing only the specified object [element].\n */\npublic fun <T> setOf(element: T): Set<T> = hashSetOf(element)\n\n/**\n * Returns an immutable map, mapping only the specified key to the\n * specified value.\n */\npublic fun <K, V> mapOf(pair: Pair<K, V>): Map<K, V> = hashMapOf(pair)\n\n/**\n * Fills the list with the provided [value].\n *\n * Each element in the list gets replaced with the [value].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.fill(value: T): Unit {\n    for (index in 0..lastIndex) {\n        this[index] = value\n    }\n}\n\n/**\n * Randomly shuffles elements in this list.\n *\n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.shuffle(): Unit = shuffle(Random)\n\n/**\n * Returns a new list with the elements of this list randomly shuffled.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> Iterable<T>.shuffled(): List<T> = toMutableList().apply { shuffle() }\n\n/**\n * Sorts elements in the list in-place according to their natural sort order.\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T : Comparable<T>> MutableList<T>.sort(): Unit {\n    collectionsSort(this, naturalOrder())\n}\n\n/**\n * Sorts elements in the list in-place according to the order specified with [comparator].\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T> MutableList<T>.sortWith(comparator: Comparator<in T>): Unit {\n    collectionsSort(this, comparator)\n}\n\nprivate fun <T> collectionsSort(list: MutableList<T>, comparator: Comparator<in T>) {\n    if (list.size <= 1) return\n\n    val array = copyToArray(list)\n    sortArrayWith(array, comparator)\n\n    for (i in 0 until array.size) {\n        list[i] = array[i]\n    }\n}\n\ninternal actual fun <T> arrayOfNulls(reference: Array<T>, size: Int): Array<T> {\n    return arrayOfNulls<Any>(size).unsafeCast<Array<T>>()\n}\n\n@SinceKotlin(\"1.3\")\n@PublishedApi\n@JsName(\"arrayCopy\")\ninternal fun <T> arrayCopy(source: Array<out T>, destination: Array<in T>, destinationOffset: Int, startIndex: Int, endIndex: Int) {\n    AbstractList.checkRangeIndexes(startIndex, endIndex, source.size)\n    val rangeSize = endIndex - startIndex\n    AbstractList.checkRangeIndexes(destinationOffset, destinationOffset + rangeSize, destination.size)\n\n    if (js(\"ArrayBuffer\").isView(destination) && js(\"ArrayBuffer\").isView(source)) {\n        val subrange = source.asDynamic().subarray(startIndex, endIndex)\n        destination.asDynamic().set(subrange, destinationOffset)\n    } else {\n        if (source !== destination || destinationOffset <= startIndex) {\n            for (index in 0 until rangeSize) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        } else {\n            for (index in rangeSize - 1 downTo 0) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        }\n    }\n}\n\n// no singleton map implementation in js, return map as is\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<K, V>.toSingletonMapOrSelf(): Map<K, V> = this\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<out K, V>.toSingletonMap(): Map<K, V> = this.toMutableMap()\n\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <T> Array<out T>.copyToArrayOfAny(isVarargs: Boolean): Array<out Any?> =\n    if (isVarargs)\n    // no need to copy vararg array in JS\n        this\n    else\n        this.copyOf()\n\n\n\n@PublishedApi\ninternal actual fun checkIndexOverflow(index: Int): Int {\n    if (index < 0) {\n        throwIndexOverflow()\n    }\n    return index\n}\n\n@PublishedApi\ninternal actual fun checkCountOverflow(count: Int): Int {\n    if (count < 0) {\n        throwCountOverflow()\n    }\n    return count\n}\n\n\n/**\n * JS map and set implementations do not make use of capacities or load factors.\n */\n@PublishedApi\ninternal actual fun mapCapacity(expectedSize: Int) = expectedSize\n\n/**\n * Checks a collection builder function capacity argument.\n * In JS no validation is made in Map/Set constructor yet.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@PublishedApi\ninternal actual fun checkBuilderCapacity(capacity: Int) {\n    require(capacity >= 0) { \"capacity must be non-negative.\" }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"PreconditionsKt\")\n\npackage kotlin\n\nimport kotlin.contracts.contract\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    require(value) { \"Failed requirement.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is null. Otherwise returns the not null value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return requireNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    } else {\n        return value\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    check(value) { \"Check failed.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return checkNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage]  if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    } else {\n        return value\n    }\n}\n\n\n/**\n * Throws an [IllegalStateException] with the given [message].\n *\n * @sample samples.misc.Preconditions.failWithError\n */\n@kotlin.internal.InlineOnly\npublic inline fun error(message: Any): Nothing = throw IllegalStateException(message.toString())\n","package react\n\nimport kotlinext.js.*\nimport kotlin.reflect.*\n\n@DslMarker\nannotation class ReactDsl\n\n@ReactDsl\nopen class RBuilder {\n    val childList = mutableListOf<Any>()\n\n    fun <T : Child> child(element: T): T {\n        childList.add(element)\n        return element\n    }\n\n    operator fun Child.unaryPlus() {\n        childList.add(this)\n    }\n\n    operator fun String.unaryPlus() {\n        childList.add(this)\n    }\n\n    fun <P : RProps> child(\n        type: Any,\n        props: P,\n        children: List<Any>\n    ): ReactElement =\n        child(createElement(type, props, *children.toTypedArray()))\n\n    fun <P : RProps> child(\n        type: Any,\n        props: P,\n        handler: RHandler<P>\n    ): ReactElement {\n        val children = with(RElementBuilder(props)) {\n            handler()\n            childList\n        }\n        return child(type, props, children)\n    }\n\n    operator fun <P : RProps> RClass<P>.invoke(\n        handler: RHandler<P>\n    ): ReactElement =\n        child(this, jsObject(), handler)\n\n    operator fun <T> RProvider<T>.invoke(\n        value: T,\n        handler: RHandler<RProviderProps<T>>\n    ): ReactElement =\n        child(this, jsObject { this.value = value }, handler)\n\n    operator fun <T> RConsumer<T>.invoke(\n        handler: RBuilder.(T) -> Unit\n    ): ReactElement =\n        child(this, jsObject<RConsumerProps<T>> {\n            this.children = { value ->\n                buildElements { handler(value) }\n            }\n        }) {}\n\n    fun <P : RProps> RClass<P>.node(\n        props: P,\n        children: List<Any> = emptyList()\n    ): ReactElement =\n        child(this, clone(props), children)\n\n    fun <P : RProps> child(\n        klazz: KClass<out Component<P, *>>,\n        handler: RHandler<P>\n    ): ReactElement =\n        klazz.rClass.invoke(handler)\n\n    inline fun <P : RProps, reified C : Component<P, *>> child(\n        noinline handler: RHandler<P>\n    ): ReactElement =\n        child(C::class, handler)\n\n    fun <T, P : RProps> childFunction(\n        klazz: KClass<out Component<P, *>>,\n        handler: RHandler<P>,\n        children: RBuilder.(T) -> Unit\n    ): ReactElement =\n        child(\n            type = klazz.rClass,\n            props = RElementBuilder(jsObject<P>()).apply(handler).attrs,\n            children = listOf { value: T -> buildElement { children(value) } }\n        )\n\n    inline fun <T, P : RProps, reified C : Component<P, *>> childFunction(\n        noinline handler: RHandler<P>,\n        noinline children: RBuilder.(T) -> Unit\n    ): ReactElement =\n        childFunction(C::class, handler, children)\n\n    fun <P : RProps> node(\n        klazz: KClass<out Component<P, *>>,\n        props: P,\n        children: List<Any> = emptyList()\n    ): ReactElement =\n        klazz.rClass.node(props, children)\n\n    inline fun <P : RProps, reified C : Component<P, *>> node(\n        props: P,\n        children: List<Any> = emptyList()\n    ): ReactElement =\n        node(C::class, props, children)\n\n    fun RProps.children() {\n        childList.addAll(Children.toArray(children))\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    fun <T> RProps.children(value: T) {\n        childList.add((children as (T) -> Any).invoke(value))\n    }\n}\n\nopen class RBuilderMultiple : RBuilder()\n\nfun buildElements(handler: RBuilder.() -> Unit): dynamic {\n    val nodes = RBuilder().apply(handler).childList\n    return when (nodes.size) {\n        0 -> null\n        1 -> nodes.first()\n        else -> createElement(Fragment, js {}, *nodes.toTypedArray())\n    }\n}\n\nopen class RBuilderSingle : RBuilder()\n\ninline fun buildElement(handler: RBuilder.() -> Unit): ReactElement =\n    RBuilder().apply(handler)\n        .childList.first()\n        .unsafeCast<ReactElement>()\n\nopen class RElementBuilder<out P : RProps>(open val attrs: P) : RBuilder() {\n    fun attrs(handler: P.() -> Unit) {\n        attrs.handler()\n    }\n\n    var key: String\n        @Deprecated(message = \"Write-only property\", level = DeprecationLevel.HIDDEN)\n        get() = error(\"\")\n        set(value) {\n            attrs.key = value\n        }\n\n    var ref: RRef\n        @Deprecated(message = \"Write-only property\", level = DeprecationLevel.HIDDEN)\n        get() = error(\"\")\n        set(value) {\n            attrs.ref = value\n        }\n\n    fun ref(handler: (dynamic) -> Unit) {\n        attrs.ref(handler)\n    }\n}\n\ntypealias RHandler<P> = RElementBuilder<P>.() -> Unit\n\nfun <P : RProps> forwardRef(handler: RBuilder.(P, RRef) -> Unit): RClass<P> =\n    rawForwardRef { props, ref ->\n        buildElements { handler(props, ref) }\n    }\n\ntypealias FunctionalComponent<P> = (props: P) -> dynamic\n\n/**\n * Get functional component from [func]\n */\nfun <P : RProps> functionalComponent(\n    func: RBuilder.(props: P) -> Unit\n): FunctionalComponent<P> =\n    { props: P ->\n        buildElements {\n            func(props)\n        }\n    }\n\n/**\n * Append functional component [component] as child of current builder\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\nfun <P : RProps> RBuilder.child(\n    component: FunctionalComponent<P>,\n    props: P = jsObject(),\n    handler: RHandler<P> = {}\n): ReactElement =\n    child(component, props, handler)\n\nfun <T, P : RProps> RBuilder.childFunction(\n    component: FunctionalComponent<P>,\n    handler: RHandler<P> = {},\n    children: RBuilder.(T) -> Unit\n): ReactElement =\n    childFunction(component, jsObject<P>(), handler, children)\n\nfun <T, P : RProps> RBuilder.childFunction(\n    component: FunctionalComponent<P>,\n    props: P,\n    handler: RHandler<P> = {},\n    children: RBuilder.(T) -> Unit\n): ReactElement =\n    child(\n        type = component,\n        props = RElementBuilder(props).apply(handler).attrs,\n        children = listOf { value: T -> buildElement { children(value) } }\n    )\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","package kotlinext.js\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninline fun <T : Any> jsObject(): T =\n    js(\"({})\")\n\ninline fun <T : Any> jsObject(builder: T.() -> Unit): T =\n    jsObject<T>().apply(builder)\n\ninline fun js(builder: dynamic.() -> Unit): dynamic = jsObject(builder)\n\nfun <T : Any> clone(obj: T) = Object.assign(jsObject(), obj)\n\ninline fun <T : Any> assign(obj: T, builder: T.() -> Unit) = clone(obj).apply(builder)\n\nfun toPlainObjectStripNull(obj: Any) = js {\n    for (key in Object.keys(obj)) {\n        val value = obj.asDynamic()[key]\n        if (value != null) this[key] = value\n    }\n}\n","package react\n\nimport kotlinext.js.*\nimport kotlinx.coroutines.*\nimport kotlin.js.*\nimport kotlin.reflect.*\n\nexternal interface Child\n\nfun Child.isString(): Boolean = asDynamic() is String\n\nfun Child.asStringOrNull(): String? = when {\n    isString() -> asDynamic()\n    else -> null\n}\n\nfun Child.asElementOrNull(): ReactElement? = when {\n    asJsObject().hasOwnProperty(\"\\$\\$typeof\") -> asDynamic()\n    else -> null\n}\n\nexternal interface ReactElement : Child {\n    val props: RProps\n}\n\nfun Children.forEachElement(children: Any?, handler: (ReactElement) -> Unit) =\n    forEach(children) {\n        val element = it.asElementOrNull()\n        element?.let(handler)\n    }\n\ninline fun <P : RProps> cloneElement(\n    element: ReactElement,\n    vararg child: Any?,\n    props: P.() -> Unit\n): ReactElement = cloneElement(element, jsObject(props), *child)\n\nfun clone(element: dynamic, props: dynamic, child: Any? = null): ReactElement =\n    cloneElement(element, props, *Children.toArray(child))\n\nval <P : RProps> KClass<out Component<P, *>>.rClass: RClass<P>\n    get() = js.unsafeCast<RClass<P>>()\n\n// 16.6+\nfun <P : RProps> rLazy(loadComponent: suspend () -> RClass<P>): RClass<P> =\n    lazy {\n        Promise<RClass<P>> { resolve, reject ->\n            GlobalScope.launch {\n                try {\n                    resolve(loadComponent())\n                } catch (e: Throwable) {\n                    reject(e)\n                }\n            }\n        }\n    }\n\n// 16.6+\nfun SuspenseProps.fallback(handler: RBuilder.() -> Unit) {\n    asDynamic().fallback = buildElements(handler)\n}\n\n/**\n * Usage:\n *\n * companion object : RStatics<RProps, RState, RComponent, Nothing>(RComponent::class) {\n *     init {\n *         defaultProps = ...\n *         ...\n *     }\n * }\n *\n * in your class components\n */\nopen class RStatics<P : RProps, S : RState, C : Component<P, S>, CTX : RContext<Any>?>(\n    klazz: KClass<C>\n) : RComponentClassStatics<P, S, CTX> by klazz.js.unsafeCast<RComponentClassStatics<P, S, CTX>>()\n","package react\n\nimport kotlinext.js.*\nimport kotlin.reflect.KClass\n\n// Props\nexternal interface RProps\n\nval RProps.children: Any\n    get() = asDynamic().children\n\nvar RProps.key: String\n    @Deprecated(message = \"Write-only property\", level = DeprecationLevel.HIDDEN)\n    get() = error(\"\")\n    set(value) {\n        asDynamic().key = value\n    }\n\nvar RProps.ref: RRef\n    @Deprecated(message = \"Write-only property\", level = DeprecationLevel.HIDDEN)\n    get() = error(\"\")\n    set(value) {\n        asDynamic().ref = value\n    }\n\nfun <T> RProps.ref(ref: (T?) -> Unit) {\n    asDynamic().ref = ref\n}\n\n// State\nexternal interface RState\n\nclass BoxedState<T>(var state: T) : RState\n\n// Error info\nexternal interface RErrorInfo\n\nval RErrorInfo.componentStack: Any\n    get() = asDynamic().componentStack\n\n// TODO: Should extend RComponentClassStatics, but has problems with generic params\nexternal interface RClass<in P : RProps> : RComponentClassStatics<RProps, RState, RContext<Any>?>\n\nexternal interface RComponentClassStatics<P : RProps, S : RState, C : RContext<Any>?> {\n    var displayName: String?\n\n    var defaultProps: P?\n\n    var contextType: C\n\n    var getDerivedStateFromProps: ((P, S) -> S?)?\n\n    var getDerivedStateFromError: ((Throwable) -> S?)?\n}\n\nexternal interface RProviderProps<T> : RProps {\n    var value: T\n}\n\nexternal interface RProvider<T> : RClass<RProviderProps<T>>\n\nexternal interface RConsumerProps<T> : RProps {\n    var children: (T) -> Any\n}\n\nexternal interface RConsumer<T> : RClass<RConsumerProps<T>>\n\n// Context (16.3+)\nexternal interface RContext<T> {\n    val Provider: RProvider<T>\n    val Consumer: RConsumer<T>\n}\n\n// Refs (16.3+)\nexternal interface RRef\n\nexternal interface RReadableRef<out T> : RRef {\n    val current: T?\n}\n\nfun <S : RState> Component<*, S>.setState(buildState: S.() -> Unit) =\n    setState({ assign(it, buildState) })\n\ninline fun <P : RProps> rFunction(\n    displayName: String,\n    crossinline render: RBuilder.(P) -> Unit\n): RClass<P> {\n    val fn = { props: P -> buildElements { render(props) } }\n    return fn.unsafeCast<RClass<P>>()\n        .also { it.displayName = displayName }\n}\n\nabstract class RComponent<P : RProps, S : RState> : Component<P, S> {\n    constructor() : super() {\n        state = jsObject { init() }\n    }\n\n    constructor(props: P) : super(props) {\n        state = jsObject { init(props) }\n    }\n\n    open fun S.init() {}\n\n    // if you use this method, don't forget to pass props to the constructor first\n    open fun S.init(props: P) {}\n\n    fun RBuilder.children() {\n        props.children()\n    }\n\n    fun <T> RBuilder.children(value: T) {\n        props.children(value)\n    }\n\n    abstract fun RBuilder.render()\n\n    override fun render() = buildElements { render() }\n}\n\nabstract class RPureComponent<P : RProps, S : RState> : PureComponent<P, S> {\n    constructor() : super() {\n        state = jsObject { init() }\n    }\n\n    constructor(props: P) : super(props) {\n        state = jsObject { init(props) }\n    }\n\n    open fun S.init() {}\n\n    // if you use this method, don't forget to pass props to the constructor first\n    open fun S.init(props: P) {}\n\n    fun RBuilder.children() {\n        props.children()\n    }\n\n    fun <T> RBuilder.children(value: T) {\n        props.children(value)\n    }\n\n    abstract fun RBuilder.render()\n\n    override fun render() = buildElements { render() }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;uBAoFA,+C;oBCtEA,qC;mCC0HA,gD;;;;;;;;;;;;;;EChIA,oB;IAEI,iBHgFoD,gB;G;qCG9EpD,mB;IACI,cAAU,WAAI,OAAJ,C;IACV,OAAO,O;G;yCAGX,qB;IACI,cAAU,WAAI,SAAJ,C;G;yCAGd,qB;IACI,cAAU,WAAI,SAAJ,C;G;qCAGd,iC;IAKI,0BAAM,2BAAc,IAAd,EAAoB,KAApB,SFfwD,YEe5B,QFf4B,CEexD,EAAN,C;G;qCAEJ,gC;ICqCgB,gBDhCQ,oBAAgB,KAAhB,C;IAChB,kB;IADJ,eAEI,mB;IAEJ,OAAO,mBAAM,IAAN,EAAY,KAAZ,EAAmB,QAAnB,C;G;sCAGX,8B;IAGI,0BAAM,SAAN,EE3CJ,EF2CI,EAAwB,OAAxB,C;G;sCAEJ,qC;IE1Cc,kBAHd,E;ID8EA,WD7B2B,c;IAAvB,0BAAM,SAAN,EC8BG,WD9BH,EAA6C,OAA7C,C;G;EAOsB,8E;IAAA,4B;MAAE,2BAAQ,aAAR,C;MAAe,W;K;G;EADnB,wD;IAAA,wB;MACZ,qBAAc,4DAAd,C;K;G;EAEL,2C;IAAC,W;G;sCAPR,8B;IEhDc,kBAHd,E;ID8EA,WDvBQ,YAAgB,sC;IADpB,0BAAM,SAAN,ECyBG,WDzBH,EAIG,sBAJH,C;G;oCAMJ,sC;IAEI,wB;MAAA,WAAsB,W;IAEtB,0BAAM,SAAN,EAAY,MAAM,KAAN,CAAZ,EAA0B,QAA1B,C;G;qCAEJ,0B;IAII,OAAa,oBAAP,WAAN,KAAM,CAAO,EAAO,OAAP,C;G;uGAEjB,yB;IAAA,gC;IAAA,oC;MAGI,0CAAgB,OAAhB,C;K;GAHJ,C;EAa0B,yD;IAAA,wB;MA8Cf,gBAAX,c;MA9CuD,iBCPvD,SDOuD,Q;MAAf,OA+CzB,MCrDR,SDqDF,UAAU,C;K;G;6CAvDf,oC;IAMqB,sBAAN,KAAM,C;IAC0B,gBAA/B,oBEpFhB,EFoFgB,C;IAAqC,OCNrD,W;IDII,gCCHG,SDKuD,MAF1D,EAGe,OAAO,uCAAP,CAHf,C;G;uHAMJ,yB;IAAA,gC;IAAA,8C;MAII,kDAAwB,OAAxB,EAAiC,QAAjC,C;K;GAJJ,C;oCAMA,kC;IAGI,wB;MAAA,WAAsB,W;IAEtB,OAAa,kBAAP,WAAN,KAAM,CAAO,EAAK,KAAL,EAAY,QAAZ,C;G;qGAEjB,yB;IAAA,0D;IAAA,gC;IAAA,4C;MAEI,wB;QAAA,WAAsB,W;MAEtB,yCAAe,KAAf,EAAsB,QAAtB,C;K;GAJJ,C;wCAMA,qB;IACc,OAAV,cAAU,EAAO,QAAS,SAAQ,uBAAR,CAAhB,C;G;wCAGd,4B;IAEmB,Q;IAAf,cAAU,WAA6B,CAAxB,0EAAwB,EAAO,KAAP,CAA7B,C;G;;EAMlB,gC;IAEuB,IAAZ,I;IADgB,gBAAX,c;IAAiB,OC1C7B,W;ID0CA,YCzCO,SDyC+B,U;IAC/B,QAAM,KAAM,KAAZ,C;WACH,C;QAAK,W;QAAL,K;WACA,C;QAAW,aAAN,KAAM,C;QAAX,K;cACsB,mC;QEzHZ,kBAHd,E;QF4HY,0CC7CL,WD6CK,SFjHsD,YEiHtB,KFjHsB,CEiHtD,E;QAHL,K;;IAAP,W;G;EAcsC,gC;IAAsB,mB;IAArB,4B;G;kEAAA,Y;IAAA,2B;G;4CACvC,mB;IACU,QAAN,UAAM,C;G;gEAIN,Y;IDHyC,MAAM,2BCIjC,EDJ+D,WAA9B,C;G,OCK/C,iB;IACI,oBAAY,KAAZ,C;G;gEAIJ,Y;IDVyC,MAAM,2BCWjC,EDX+D,WAA9B,C;G,OCY/C,iB;IACI,oBAAY,KAAZ,C;G;0CAGR,mB;IACU,IAAN,UAAM,EAAI,OAAJ,C;G;;EGtHV,+B;IAAQ,wB;G;EChCR,iC;IAAQ,OAAA,SAAY,S;G;EAKpB,mC;IACI,gBAAkB,K;G;EAMtB,mC;IACI,gBAAkB,K;G;EAG1B,6B;IACI,gBAAkB,G;G;EAuDT,6C;IAAA,qB;MAAE,cAAW,kB;MFpE8C,gBAAX,MEoEvC,EFpEuC,C;MAAiB,ODqE1E,W;MGDW,OHEJ,S;K;G;EGHX,yC;IACI,mBAAS,2BAAT,C;G;;;sCAoBA,qB;G;sCAEA,4B;G;yCAGA,qB;IACU,2BAAN,UAAM,C;G;0CAGV,4B;IACU,2BAAN,UAAM,EAAS,KAAT,C;G;EAK4B,mD;IAAA,4B;MAAE,wC;MAAS,W;K;G;gCAAjD,Y;IAAwB,qBAAc,8BAAd,C;G;;EAvBxB,gC;IAAA,oD;IAAgB,qB;IADpB,sB;IFrFkB,gBAHd,E;IE0FuB,mBHZvB,SGYuB,C;IAAnB,cHXG,S;IGUP,Y;G;;;;;;;;;;;;;;;;;"}